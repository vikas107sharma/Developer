1Ô∏è‚É£ Python + Kafka

Problem: Write a Python producer that reads a JSON file with customer orders and publishes each order to a Kafka topic. Then write a consumer that filters only ‚Äúhigh-value‚Äù orders (>‚Çπ10,000) and prints them.

What you test: Kafka client library usage, message serialization, consumer group management, filtering logic.

2Ô∏è‚É£ Kafka Consumer Offset Handling

Problem: Implement a Python Kafka consumer that manually commits offsets only after processing a message successfully. Simulate a crash and show that the consumer reprocesses uncommitted messages.

What you test: At-least-once semantics, offset management.

3Ô∏è‚É£ AWS Lambda + S3 + Python

Problem: Write a Lambda function in Python triggered by an S3 upload event. When a CSV file is uploaded, parse it, count rows, and store the result in DynamoDB (or print to CloudWatch logs if no DB).

What you test: AWS SDK usage, Lambda constraints, event handling.

4Ô∏è‚É£ Redis Caching Layer

Problem: Write a Python function that fetches user details from an API (or mock DB), caches it in Redis with TTL=60s. On subsequent calls within TTL, return from Redis instead of DB.

What you test: Redis connection handling, TTL caching pattern, serialization.

5Ô∏è‚É£ Celery Task Queue

Problem: Using Celery + Redis broker, create a Python app where one task generates random numbers and another task processes them (e.g., find prime numbers). Chain them using Celery‚Äôs chain or chord.

What you test: Celery setup, async task execution, chaining.

6Ô∏è‚É£ Retry Mechanism with Celery

Problem: Write a Celery task that simulates a flaky API call (50% failure rate) and retries up to 3 times with exponential backoff.

What you test: Celery retry, error handling.

7Ô∏è‚É£ Dockerized Python App

Problem: Containerize a small Python Flask API that exposes two endpoints: one writes a record to Redis, another reads from Redis. Provide a docker-compose.yml with Redis and the app.

What you test: Dockerfile, Docker Compose, environment variable handling.

8Ô∏è‚É£ Stream Processing with Kafka + Redis

Problem: Consume real-time ‚Äúclickstream‚Äù messages from Kafka (JSON with user_id, url), store a rolling count per user in Redis, and expose an API endpoint to retrieve counts.

What you test: Streaming processing logic, Redis atomic increments, integration.

9Ô∏è‚É£ Lambda + Docker Image

Problem: Package a Python Lambda function with dependencies (e.g., Pandas) as a Docker image and deploy it. The function reads a JSON file from S3 and outputs transformed data to another bucket.

What you test: Lambda container image packaging, AWS CLI, Docker.

üîü Celery Monitoring / Scaling

Problem: Create Celery workers with autoscaling simulation ‚Äî start multiple workers and show how tasks distribute across them. Print worker ID for each task.

What you test: Concurrency concepts, Celery‚Äôs distributed behavior.